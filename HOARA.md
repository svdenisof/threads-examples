## Задача реализовать классический монитор Хоара

на примере задачи “читатели-писатели” с использованием событий и с включением в программу одного мьютекса. Использовать четыре функции:

- BeginWrite()- функция блокировки разделяемого ресурса для его инкремента;
- EndWrite()- функция снятия блокировки с разделяемого ресурса после записи;
- BeginRead() — функция блокировки разделяемого ресурса для выполнения операции чтения;
- EndRead()- функция снятия блокировки с разделяемого ресурса после завершения операции чтения.

В качестве разделяемого ресурса использовать счетчик, который в процессе работы “писателя” инкрементируется на единицу. Минимальное количество “писателей” и “читателей” с которыми должна работать программа — 5 и 3 соответственно.

## Анализ задачи читатели-писатели

В задаче существуют два вида потоков:

1. потребители (или «читателями») — только читают данные, не меняют содержимого базы данных, поэтому несколько таких потоков могут обращаться к такой базе данных одновременно;
2. производители (или «писателями») — модифицируют данные, может изменять данные в базе, и поэтому он должен обладать к ней исключительным, монопольным доступом.

Пока с базой данных работает писатель — никакие другие потоки (и писатели и читатели) работать с базой данных не должны. Такой режим монопольного доступа организуется для отдельных записей баз данных, а не для базы данных целиком. Таким образом, должны выполняться следующие правила:

1. когда один поток пишет в область общих данных — другие потоки не могут не считывать, не записывать в эту область;
2. когда один поток читает из области общих данных — другие потоки не могут туда ничего записывать, но могут читать данные.

## Монитор Хоара

Монитор — это механизм организации параллелизма, который содержит как данные, так и процедуры, необходимые для реализации динамического распределения конкретного общего ресурса или группы общих ресурсов. Процесс, желающий получить доступ к разделяемым переменным, должен обратиться к монитору, который либо предоставит доступ, либо откажет в нем. Необходимость входа в монитор с обращением к какой-либо его процедуре (например, с запросом на выделение требуемого ресурса) может возникать у многих процессов. Однако вход в монитор находится под жестким контролем — здесь осуществляется взаимоисключение процессов, так что в каждый момент времени только одному процессу разрешается войти в монитор. Процессам, которые хотят войти в монитор, когда он уже занят, приходится ждать, причем режимом ожидания автоматически управляет сам монитор.

При отказе в доступе монитор блокирует обратившийся к нему процесс и определяет условие, по которому процесс ждет. Проверка условия выполняется самим монитором, который и деблокирует ожидающий процесс. Поскольку механизм монитора гарантирует взаимоисключение процессов, отсутствуют серьезные проблемы, связанные с организацией параллельных взаимодействующих процессов. Ко всем данным монитора (глобальным или локальным) можно обращаться только изнутри монитора. При первом обращении монитор присваивает своим переменным начальные значения. При каждом последующем обращении используются те значения переменных, которые сохранились от предыдущего обращения. Если процесс обращается к некоторой процедуре монитора и обнаруживается, что соответствующий ресурс уже занят, эта процедура монитора выдает команду ожидания с указанием условия ожидания. Процесс, переводящийся в режим ожидания, должен вне монитора ждать того момента, когда необходимый ему ресурс освободится. Со временем процесс, который занимал данный ресурс, обратится к монитору, чтобы возвратить ресурс системе. Соответствующая процедура монитора при этом может просто принять уведомление о возвращении ресурса или, если уже имеются процессы, ожидающие освобождения данного ресурса, выполнить команду извещения (сигнализации), чтобы один из ожидающих процессов мог получить данный ресурс и покинуть монитор. Процесс, ожидающий освобождения некоторого ресурса, должен находиться вне монитора, чтобы другой процесс имел возможность войти в монитор и возвратить ему этот ресурс.

## Решение задачи “читатели-писатели”

Для работы с монитором создаются параллельные потоки, имитирующие работу писателей и читателей. Количество писателей определяется переменной NumWriters, количество читателей — переменной NumReaders (в программе: 3 и 5 соответственно). В качестве разделяемого ресурса выступает целочисленная переменная SHARED_RESOURCE, при каждом обращении к ней читатели должны считывать ее значение, а писатели — увеличивать на единицу. В каждый конкретный момент времени может работать только один писатель; когда какой-либо писатель работает, логическая переменная writeLock имеет истинное значение. Ни один из читателей не может работать во время работы какого-либо писателя. Переменная readers указывает количество активных читателей. Когда число читателей оказывается равным нулю, ожидающий поток-писатель получает возможность начать работу. Для доступа к разделяемой переменной SHARED_RESOURCE в программе используются события; для читателей — CanRead (со сбросом вручную), а для писателей — CanWrite (с автоматическим сбросом). Новый поток-читатель не может продолжить свое выполнение, пока не настанет событие CanRead, а новый поток-писатель — пока не настанет событие CanWrite.

Когда потоку-читателю необходимо выполнить чтение данных, он вызывает процедуру входа в монитор BeginRead(), затем инкрементирует переменную queueReaders, показывая свое присутствие в очереди на чтение данных новому потоку-писателю, поток-читатель может находиться внутри функции BeginRead(), пока никакой другой поток-писатель не пишет данные и не претендует на выполнение записи данных. Выполнение этих условий определяются двумя переменными writeLock и queueWriters. Если выполняется какое-либо из условий поток-читатель ожидает наступления события CanRead внутри монитора, после наступления события, поток-читатель убирает себя из очереди читателей, декриментируя переменную queueReaders и инкрементирует переменную readers. Функция BeginRead() завершается оповещением переменной CanRead, чтобы другие ждущие потоки смогли продолжить чтение данных.

По окончанию процесса чтения читатель вызывает функцию EndRead(), в ней читатель уменьшает переменную readers на 1, сокращая тем самым количество активных читателей. Когда в системе не остается ни одного читателя, поток выдает команду оповещения CanWrite, чтобы ждущий своей очереди поток-писатель смог продолжить работу, исключив тем самым бесконечное откладывание ждущих писателей.

Когда потоку-писателю необходимо произвести запись, он вызывает процедуру входа в монитор BeginWrite(), инкрементирует переменную queueWriters, показывая всем остальным потокам свое намерение произвести запись данных. Так как поток-писатель обладает монопольным доступом к разделяемому ресурсу, необходимо проверить, чтобы в текущий момент в системе не находились работающие потоки-читатели или какой-либо активный поток писатель (на что указывают переменные readers и writeLock), в противном случае данному писателю придется подождать наступления события CanWrite. После того, как событие CanWrite наступит поток писатель уменьшает на 1 переменную queueWriters и присваивает 1 переменной writeLock, блокируя тем самым доступ к разделяемому ресурсу остальным потокам.

Когда поток-писатель заканчивает свою работу , он вызывает функцию EndWrite() и устанавливает для переменной writeLock ложное значение; затем он проверяет нет ли ожидающего потока-читателя (переменная queueReaders), если есть, то инициируется событие CanRead, в противном случае событие CanWrite.

Программа завершает свою работу при условии, что разделяемый ресурс достиг максимальной отметки (значения) MAX_VAL.

[Блок-схема алгоритма](https://pro-prof.com/archives/1462) работы «писателя»:  
![](https://pro-prof.com/wp-content/uploads/2020/02/flowchart-hoar_1.png)

[Блок-схема алгоритма](https://pro-prof.com/archives/1462) работы «читателя»:  
![](https://pro-prof.com/wp-content/uploads/2020/02/flowchart-hoar_2.png)

## Моделирование монитора Хоара на языке Си

```C
#include <iostream>
#include <cmath>
#include <windows.h>
#include <process.h>

using namespace std;

HANDLE CanWrite; // Переменная-событие, пропускающая писателей
HANDLE CanRead; // Переменная-событие, пропускающая читателей
HANDLE MUTEX; // Переменная mutex, защищает переменную Stop
LONG SHARED_RESOURCE = 0; //Разделяемая переменная-ресурс
LONG MAX_VAL = 500; // Максимальное значение
LONG Stop = 0; // Флаг остановки выполнения программы, если 1, программа
// завершает выполнение
LONG readers = 0; //Переменная-счетчик количество читателей
LONG writeLock = 0; //Флаг блокировки, 1, если писатель записывает данные
LONG queueReaders = 0; //Количество читателей, ожидающих наступления события CanRead
LONG queueWriters = 0; //Количество писателей, ожидающих наступления события CanWrite

void BeginWrite(int);
void EndWrite();
unsigned stdcall Write(PVOID);
void BeginRead(int);
void EndRead();
unsigned stdcall Read(PVOID);
LONG Show(LONG &);

int main(void) {
	int NumReaders = 5, NumWriters = 3;
	int Qty = NumReaders + NumWriters;
	CanWrite = CreateEvent(NULL, FALSE, TRUE, NULL);
	CanRead = CreateEvent(NULL, TRUE, FALSE, NULL);
	MUTEX = CreateMutex(NULL, FALSE, NULL);
	
	for (int i = 0; i < Qty; i++)
		if (i < NumReaders)
			_beginthreadex(NULL, 0, Read, (PVOID *)i, 0, NULL);
		else
			_beginthreadex(NULL, 0, Write, (PVOID *)i, 0, NULL);
		getchar();
		return 0;
}

unsigned stdcall Write(PVOID Id) {
	int id = (int)Id;
	while (!Stop) {
		BeginWrite(id);
		if (SHARED_RESOURCE < MAX_VAL) {
			Sleep(rand() % 20);
			InterlockedExchangeAdd(&SHARED_RESOURCE, 1);
			cout << "\t<WRITER#" << id << ", MODIFIED VALUE:
			"<<Show(SHARED_RESOURCE)<<" >
			"<<endl;
		} else {
			WaitForSingleObject(MUTEX, INFINITE);
			Stop = 1;
			ReleaseMutex(MUTEX);
		}

		EndWrite();
	}
	return 0;
}

// Функция входа в монитор перед началом записи данных

void BeginWrite(int id) {
	// Постановка в очередь на ожидание записи данных
	InterlockedExchangeAdd(&queueWriters, 1);
	// Ожидание в случае выполнения чтения или записи данных
	if (readers > 0 || writeLock == 1) {
		ResetEvent(CanWrite);
	}
	WaitForSingleObject(CanWrite, INFINITE);
	// Блокировка всех читателей и писателей InterlockedExchangeAdd(&writeLock,
	// 1); InterlockedExchangeAdd(&queueWriters, -1); // Выход из очереди
}

// Функция выхода из монитора по окончанию записи данных
void EndWrite() {
	// Снятие блокировки читателей и писателей
	InterlockedExchangeAdd(&writeLock, -1);
	if (queueReaders > 0) // Если читатель ждет входа, оповестить об этом
		SetEvent(CanRead);
	else // Оповестить писателей, если ожидающих читателей нет
		SetEvent(CanWrite);
}

unsigned stdcall Read(PVOID Id) {
	int id = (int)Id;
	while (!Stop) {
		BeginRead(id);
		Sleep(rand() % 20);
		cout << "<Reader #" << id << ", Current Value: " << Show(SHARED_RESOURCE)
		<< ">" << endl;
		EndRead();
	}
	return 0;
}

// Функция входа в монитор перед началом чтения данных

void BeginRead(int id) {
	//Постановка в очередь на ожидание чтения данных
	InterlockedExchangeAdd(&queueReaders, 1);
	// Ожидание в случае выполнения писателем записи данных
	if (writeLock == 1 || queueWriters > 0) {
		ResetEvent(CanRead);
	}
	WaitForSingleObject(CanRead, INFINITE);
	InterlockedExchangeAdd(&queueReaders, -1); // Выход из очереди
	// Увеличение количества читателей внутри монитора
	// InterlockedExchangeAdd(&readers, 1); SetEvent(CanRead);
}

// Функция выхода из монитора по окончанию чтения данных
void EndRead() {
	// Уменьшение количества читателей внутри монитора
	InterlockedExchangeAdd(&readers, -1);
	// Если читателей внутри монитора нет, разрешить писателям запись данных
	if (readers == 0) {
		SetEvent(CanWrite);
	}
}

LONG Show(LONG &resource) {
	return resource;
}
```
